15-213, Fall 20XX
 Proxy Lab: 할당된 캐싱 웹 프록시 쓰기: Thu, Nov 19
 Due: Tue, Dec 8, 11:59 PM
 최종 가능 시간 : 12월 11일 금요일 오후 11:59
 
소개
 
 웹 프록시는 웹 브라우저와 엔드 서버 사이의 중간 역할을 하는 프로그램입니다.
 웹 페이지를 얻기 위해 엔드 서버에 직접 연락하는 대신 브라우저가 프록시에 연락하여 요청을 엔드 서버에 전달합니다. 
 엔드 서버가 프록시에 응답하면 프록시는 브라우저에 응답을 보냅니다.
 프록시는 다양한 용도로 유용합니다. 
 때때로 프록시가 방화벽에서 사용되므로 방화벽 뒤의 브라우저는 프록시를 통해 방화벽 너머의 서버에만 연결할 수 있습니다. 
 프록시는 또한 익명화자 역할을 할 수 있습니다. 
 모든 식별 정보의 요청을 제거함으로써 프록시는 브라우저를 웹 서버에 익명으로 만들 수 있습니다. 
 
 프록시는 서버에서 로컬 개체 복사본을 저장한 다음 원격 서버와 다시 통신하는 대신 캐시에서 해당 개체를 읽어 
 향후 요청에 응답함으로써 웹 개체를 캐시하는 데 사용할 수도 있습니다.

 이 랩에서는 웹 개체를 캐시하는 간단한 HTTP 프록시를 작성합니다. 
 랩의 첫 번째 부분에 대해 수신 연결을 수락하고, 요청을 읽고 해석하며, 요청을 웹 서버로 전달하고, 서버의 응답을 읽고, 
 해당 응답을 해당 클라이언트로 전달하도록 프록시를 설정합니다.
 
 첫 번째 파트에서는 기본 HTTP 동작과 소켓을 사용하여 네트워크 연결을 통해 통신하는 프로그램을 작성하는 방법에 대해 배울 것입니다. 
 
 두 번째 부분에서는 프록시를 업그레이드하여 여러 개의 동시 연결을 처리합니다. 이것은 중요한 시스템 개념인 동시성을 다루는 방법을 소개할 것입니다. 
 
 세 번째와 마지막 부분에서는 최근에 액세스한 웹 콘텐츠의 간단한 메인 메모리 캐시를 사용하여 프록시에 캐싱을 추가합니다.
 
 
Part I: 순차적 웹 프록시 구현
 
 첫 번째 단계는 HTTP/1.0 GET 요청을 처리하는 기본 순차 프록시를 구현하는 것입니다. 
 POST와 같은 다른 요청 유형은 엄격하게 선택 사항입니다.
 시작할 때 프록시는 명령줄에 번호가 지정된 포트에서 들어오는 연결을 들어야 합니다. 
 연결이 설정되면 프록시는 클라이언트의 모든 요청을 읽고 요청을 해석해야 합니다. 
 클라이언트가 올바른 HTTP 요청을 보냈는지 확인해야 합니다. 
 그런 경우 적절한 웹 서버에 대한 자체 연결을 설정한 다음 클라이언트가 지정한 개체를 요청할 수 있습니다. 
 마지막으로 프록시는 서버의 응답을 읽고 클라이언트에 전달해야 합니다.
 
HTTP/1.0 GET 요청
 최종 사용자가 웹 브라우저의 주소 표시줄에 http://www.cmu.edu/hub/index.html 와 같은 URL을 입력하면 
 브라우저는 다음과 유사한 줄로 시작하는 HTTP 요청을 프록시로 보냅니다.
 
 GET http://www.cmu.edu/hub/index.html HTTP/1.1
 
 이 경우 프록시는 요청을 적어도 /hub/index.html, 호스트 이름, www.cmu.edu 및 경로 또는 쿼리와 그 다음에 오는 모든 필드로 구문 분석해야 합니다. 
 그렇게 하면 프록시는 www.cmu.edu 에 대한 연결을 열고
 
 다음과 같은 형태의 행으로 시작하는 자신의 HTTP 요청을 보내야 한다고 결정할 수 있습니다. :
 
 GET /hub/index.html HTTP/1.0
 
 HTTP 요청의 모든 행은 캐리지 리턴 '\r'로 끝나고 새 행 '\n'이 이어집니다.
 또한 중요한 것은 모든 HTTP 요청이 빈 줄로 종료된다는 것입니다. "\r\n".
 

 위의 예에서 웹 브라우저의 요청 줄은 HTTP/1.1로 끝나는 반면 프록시의 요청 줄은 HTTP/1.0으로 끝나는 것에 주목해야 합니다. 
 현대의 웹 브라우저는 HTTP/1.1 요청을 생성하지만 프록시는 이를 처리하여 HTTP/1.0 요청으로 전달해야 합니다.
 HTTP 요청은 HTTP/1.0 GET 요청의 하위 집합이라도 매우 복잡할 수 있음을 고려해야 합니다. 
 이 교재에서는 HTTP 트랜잭션의 특정 세부 사항에 대해 설명하지만 HTTP/1.0 전체 사양은 RFC 1945를 참조해야 합니다. 
 이상적으로 HTTP 요청 파서는 RFC 1945의 관련 섹션에 따라 완벽하게 강건합니다. 
 단 한 가지 세부 사항을 제외하고는 사양에서 다중 줄 요청 필드를 허용하지만 프록시에서 이 필드를 적절하게 처리할 필요는 없습니다. 
 물론, 잘못된 요청으로 인해 프록시를 조기에 중단해서는 안 됩니다.
 
요청 헤더
 이 랩의 중요한 요청 헤더는 Host, User-Agent, Connection 및 Proxy-Connection 헤더입니다.
 
 • 항상 Host 헤더를 보냅니다. 
 이 동작은 HTTP/1.0 사양에 의해 기술적으로 승인되지는 않지만 특정 웹 서버, 특히 가상 호스팅을 사용하는 서버에서 합리적인 응답을 유도해야 합니다.
 호스트 헤더는 엔드 서버의 호스트 이름을 설명합니다. 
 예를 들어, http://www.cmu.edu/hub/index.html, 에 액세스하려면 프록시에서 다음 헤더를 보냅니다.
 
 호스트: www.cmu.edu 
 
 웹 브라우저가 자신의 HTTP 요청에 자신의 호스트 헤더를 첨부할 수 있습니다. 이 경우 프록시는 브라우저와 동일한 호스트 헤더를 사용해야 합니다.
 
 • 항상 다음과 같은 User-Agent 헤더를 보내도록 선택할 수 있습니다.
 
 사용자-에이전트: Mozilla/5.0(X11; Linux x86_64; rv:10.0.3) Gecko/201305 Firefox/10.03
 
 헤더는 쓰기에서 단일 라인으로 맞지 않기 때문에 두 개의 개별 라인에 제공되지만 프록시는 헤더를 단일 라인으로 보내야 합니다.
 사용자-에이전트 헤더는 (운영 체제 및 브라우저와 같은 매개 변수 측면에서) 클라이언트를 식별하며, 
 웹 서버는 종종 자신이 서비스하는 내용을 조작하기 위해 식별 정보를 사용합니다. 
 이 특정 User-Agent: 문자열을 보내면 간단한 텔넷 형식 테스트 중에 반환되는 내용과 다양성이 향상될 수 있습니다.
 
 • 항상 다음 Connection 헤더를 보냅니다.
 
 Connection: close

 • 항상 다음 프록시 연결 헤더를 보냅니다.

 Proxy-Connection: close

 
 Connection 및 Proxy-Connection 헤더는 첫 번째 요청/응답 교환이 완료된 후에도 연결을 유지할지 여부를 지정하는 데 사용됩니다. 
 각 요청에 대해 프록시가 새 연결을 열도록 하는 것은 완벽하게 허용(및 제안)됩니다. 
 머리글의 값으로 닫기를 지정하면 프록시가 첫 번째 요청/응답 교환 후에 연결을 닫으려고 한다는 것을 웹 서버에 알립니다.
 
 사용자의 편의를 위해 설명한 User-Agent 헤더의 값은 프록시.c에서 문자열 상수로 제공됩니다.
 마지막으로 브라우저가 HTTP 요청의 일부로 추가 요청 헤더를 보낸 경우 프록시는 변경되지 않은 헤더를 전달해야 합니다.
 
포트 번호
 이 랩에는 HTTP 요청 포트와 프록시의 수신 포트라는 두 가지 중요한 포트 번호 클래스가 있습니다.
 HTTP 요청 포트는 HTTP 요청의 URL에 있는 선택적인 필드입니다. 즉, URL은 http://www.cmu.edu:8080/hub/index.html, 형식일 수 있습니다. 
 이 경우 프록시는 포트 80인 기본 HTTP 포트 대신 포트 8080의 호스트 www.cmu.edu 에 연결해야 합니다. 
 포트 번호가 URL에 포함되어 있는지 여부에 관계없이 프록시가 제대로 작동해야 합니다.
 수신 포트는 프록시가 수신 연결을 수신할 때 수신해야 하는 포트입니다. 
 프록시에 대한 수신 포트 번호를 지정하는 명령줄 인수를 수락해야 합니다. 
 예를 들어, 다음 명령을 사용하면 프록시는 포트 15213에서 연결을 수신해야 합니다.
 
 리눅스> ./ proxy 15213
 
 다른 프로세스에서 사용되지 않는 한 비특권 수신 포트(1,024보다 크고 65,536보다 작음)를 선택할 수 있습니다. 
 각 프록시는 고유한 수신 포트를 사용해야 하며 동시에 많은 사람들이 각 시스템에서 작업할 것이므로 개인 포트 번호를 선택하는 데 도움이 되도록 
 port-for-user.pl 스크립트가 제공됩니다. 
 
 사용자 ID를 기반으로 포트 번호 생성:
 linux> ./port-for-user.pl droh droh: 45806
 
 port-for-user.pl 에서 반환되는 포트 p는 항상 짝수입니다. 
 따라서 추가 포트 번호가 필요한 경우 예를 들어 Tiny 서버의 경우 p 및 p + 1.
 포트를 안전하게 사용할 수 있습니다. 
 임의의 포트를 선택하지 마십시오. 
 그렇게 하면 다른 사용자에게 방해가 될 위험이 있습니다.
 
Part II: 복수의 동시 요청 처리
 
 작업 중인 순차 프록시가 있으면 이 프록시를 변경하여 여러 요청을 동시에 처리해야 합니다. 
 동시 서버를 구현하는 가장 간단한 방법은 새 스레드를 생성하여 각 새 연결 요청을 처리하는 것입니다. 
 교과서의 섹션 12.5.5에 설명된 사전 스레드화된 서버와 같은 다른 디자인도 가능합니다.
 
 • 메모리 유출을 방지하려면 스레드를 분리 모드로 실행해야 합니다.
 • CS에 설명된 open clientfd 및 open listenfd 기능:APP3e 교재는 
   현대적이고 프로토콜에 독립적인 getaddrinfo 기능을 기반으로 하므로 스레드 안전합니다.
 
Part III: 웹 개체 캐싱
 
 랩의 마지막 부분을 위해 최근에 사용한 웹 개체를 메모리에 저장하는 캐시를 프록시에 추가합니다. 
 HTTP는 실제로 웹 서버가 서비스하는 객체를 캐시해야 하는 방법에 대한 지침을 제공하고 클라이언트가 캐시를 대신 
 사용하는 방법을 지정할 수 있는 상당히 복잡한 모델을 정의합니다. 그러나 프록시는 단순화된 접근 방식을 채택할 것입니다.
 프록시가 서버로부터 웹 개체를 수신할 때 해당 개체를 클라이언트로 전송할 때 
 해당 개체를 메모리에 캐시해야 합니다. 다른 클라이언트가 동일한 서버에 동일한 개체를 요청하는 경우 
 프록시는 서버에 다시 연결할 필요가 없으며 캐시된 개체를 다시 보내기만 하면 됩니다.
 분명히 프록시가 요청되는 모든 개체를 캐시하려면 무제한 메모리가 필요합니다. 
 또한 일부 웹 개체는 다른 개체보다 크기 때문에 하나의 거대한 개체가 전체 캐시를 소비하여 다른 개체가 캐시되지 않을 수 있습니다. 
 이러한 문제를 방지하려면 프록시에 최대 캐시 크기와 최대 캐시 개체 크기가 모두 있어야 합니다.
 
최대 캐시 크기
 프록시 캐시 전체의 최대 크기는 다음과 같습니다.
 
 MAX_CACHE_SIZE = 1 MiB
 
 캐시 크기를 계산할 때 프록시는 실제 웹 개체를 저장하는 데 사용되는 바이트만 계산해야 합니다. 
 메타데이터를 포함한 모든 관련 바이트는 무시해야 합니다.
 
최대 객체 크기
 프록시는 다음 최대 크기를 초과하지 않는 웹 개체만 캐시해야 합니다.
 
 MAX_OBject_SIZE = 100 KiB
 
 사용자의 편의를 위해 두 가지 크기 제한 모두 프록시에서 매크로로 제공됩니다.
 올바른 캐시를 구현하는 가장 쉬운 방법은 활성 연결마다 버퍼를 할당하고 서버에서 수신한 데이터를 축적하는 것입니다. 
 버퍼의 크기가 최대 개체 크기를 초과하면 버퍼를 폐기할 수 있습니다. 
 최대 개체 크기를 초과하기 전에 웹 서버의 전체 응답을 읽은 경우 개체를 캐시할 수 있습니다. 
 이 방식을 사용하면 프록시가 웹 개체에 사용할 최대 데이터 양은 다음과 같습니다. 여기서 T는 최대 활성 연결 수입니다.
 
 MAX_CACH_SIZE + T * MAX_OBject_SIZE
 
퇴거방침
 프록시의 캐시는 LRU(최소한 최근에 사용된) 퇴거 정책에 근접한 퇴거 정책을 사용해야 합니다. 
 엄격하게 LRU일 필요는 없지만, 합리적으로 가까운 것이어야 합니다. 개체를 읽는 것과 쓰는 것 모두 개체를 사용하는 것으로 간주됩니다.
 
동기화
 캐시에 대한 액세스는 스레드 안전해야 하며, 캐시 액세스가 레이스 조건에서 자유롭다는 것을 보장하는 것이 연구소의 이 부분에서 더 흥미로운 측면일 것입니다. 
 사실 캐시에서 여러 스레드를 동시에 읽을 수 있어야 한다는 특별한 요구 사항이 있습니다. 
 물론 한 번에 하나의 스레드만 캐시에 쓸 수 있도록 허용해야 하지만 독자에게는 이러한 제한이 없어야 합니다.
 따라서 하나의 큰 전용 잠금 장치로 캐시에 대한 액세스를 보호하는 것은 허용 가능한 해결책이 아닙니다. 
 캐시 분할, Pthread readers-writer 잠금 사용, 또는 semaphore를 사용하여 독자-writer 솔루션을 구현하는 것과 같은 옵션을 탐색할 수 있습니다. 
 어느 경우든 엄격하게 LRU 퇴거 정책을 시행할 필요가 없다는 사실은 여러 독자를 지원하는 데 어느 정도 유연성을 제공할 것입니다.
 
평가
 
 이번 과제는 총 70점 만점으로 등급이 매겨집니다.
 
 • 기본정확도 : 기본대리운전 40점(자동등급)
 • 동시성 : 동시 요청 처리 15점(자동 등급화)
 • 캐시: 작업 캐시 15점(자동 등급화)
 
자동 채점
 배포 자료에는 강사가 기본 정확성, 동시성 및 캐시 점수를 할당하는 데 사용할 driver.sh 이라는 오토그래더가 포함되어 있습니다. proxylab-handout 디렉토리에서:
 
 리눅스> ./드라이버.sh


견고성
 항상 그렇듯이 오류 및 잘못된 형식 또는 악의적인 입력에도 강한 프로그램을 제공해야 합니다. 
 서버는 일반적으로 장기간 실행되는 프로세스이며 웹 프록시도 예외가 아닙니다. 
 다양한 유형의 오류에 대해 장기간 실행되는 프로세스가 어떻게 반응해야 하는지 신중하게 생각해 보십시오. 
 많은 종류의 오류에 대해 귀하의 대리인이 즉시 종료하는 것은 확실히 부적절합니다.
 견고성은 세분화 오류와 같은 오류 사례에 대한 취약성, 메모리 유출 및 파일 디스크립터 유출 부족을 포함한 다른 요구 사항도 의미합니다.
 
테스트 및 디버깅
 
 간단한 오토그래더 외에도 구현을 테스트할 샘플 입력이나 테스트 프로그램이 없습니다.
 코드를 디버깅하고 올바른 구현 시기를 결정하는 데 도움이 되는 자체 테스트 및 아마도 자체 테스트 하니스를 고안해야 할 것입니다. 
 이는 정확한 작동 조건이 거의 알려지지 않고 참조 솔루션을 사용할 수 없는 현실 세계에서 귀중한 기술입니다.
 다행히 프록시를 디버깅하고 테스트하는 데 사용할 수 있는 많은 도구가 있습니다. 
 모든 코드 경로를 사용하고 기본 케이스, 일반 케이스 및 에지 케이스를 포함한 대표적인 입력 세트를 테스트해야 합니다.
 
Tiny Web 서버
 CS의 소스 코드를 배포하는 디렉토리:APP Tiny 웹 서버. 
 thttpd만큼 강력하지는 않지만 CS:APP Tiny 웹 서버는 적합하다고 생각되는 대로 쉽게 수정할 수 있습니다. 
 또한 프록시 코드의 합리적인 시작점입니다. 그리고 드라이버 코드가 페이지를 가져오는 데 사용하는 서버입니다.
 
telnet
 교재(11.5.3)에 설명된 바와 같이 telnet을 사용하여 프록시에 대한 연결을 열고 HTTP 요청을 보낼 수 있습니다.
 
curl
 curl을 사용하여 프록시를 포함한 모든 서버에 대한 HTTP 요청을 생성할 수 있습니다. 매우 유용한 디버깅 도구입니다. 
 예를 들어 프록시와 Tiny가 모두 로컬 시스템에서 실행 중이고 Tiny가 포트 15213에서 수신 중이고 
 프록시가 포트 15214에서 수신 중인 경우 다음 curl 명령을 사용하여 Tiny의 페이지를 요청할 수 있습니다.
 
 linux> curl -v --proxy http://localhost:15214 http://localhost:15213/home.html
 * 프록시 로컬 호스트 포트 15214(#0)
에 연결하려고 합니다. * 127.0.0.1... 연결 중


 * 로컬 호스트(127.0.0.1) 포트 15214(#0)
에 연결됨 > GET http://localhost:15213/home.html HTTP/1.1
 > 사용자-에이전트: curl/7.19.7(x86_64-redhat-linux-gnu)...
 > 호스트 : localhost : 15213
 > 수락 : */*
 > 프록시-연결: Keep-Alive
 >
. * HTTP 1.0, 본문 뒤에 닫기를 가정합니다
 < HTTP/1.0 200 OK
 < 서버: Tiny Web Server
 < 내용물 길이 : 120
 < 내용형 : text/html
 < 데이브 오할라론

 * 연결 닫기 #0
 
netcat
 nc라고도 알려진 netcat은 다용도 네트워크 유틸리티입니다. 텔넷과 마찬가지로 넷캣을 사용하여 서버에 대한 연결을 열 수 있습니다. 
 따라서 프록시가 포트 12345를 사용하여 catshark에서 실행되고 있다고 상상하면 
 다음과 같은 작업을 수행하여 프록시를 수동으로 테스트할 수 있습니다.
 
 sh> nc catshark.ics.cs.cmu.edu 12345
 GET http://www.cmu.edu/hub/index.html HTTP/1.0
 
 HTTP/1.1 200 OK
 ...
 
 netcat은 웹 서버에 연결할 수 있을 뿐만 아니라 서버 자체로도 작동할 수 있습니다. 
 다음 명령을 사용하면 포트 12345:
 netcat을 수신 중인 서버로 실행할 수 있습니다. 
 sh> nc -l 12345
 
 넷캣 서버를 설정하면 프록시를 통해 해당 서버의 가짜 개체에 대한 요청을 생성할 수 있으며 프록시가 넷캣에 보낸 정확한 요청을 검사할 수 있습니다.
 
웹 브라우저
 결국 최신 버전의 Mozilla Firefox를 사용하여 프록시를 테스트해야 합니다. Firefox 방문 정보
 브라우저를 최신 버전으로 자동 업데이트합니다.
 
 
 Firefox가 프록시와 함께 작동하도록 구성하려면

   환경설정>고급>네트워크>설정
 
 실제 웹 브라우저를 통해 프록시가 작동하는 것을 보는 것은 매우 흥미로울 것입니다. 
 프록시의 기능은 제한적이지만 프록시를 통해 대부분의 웹 사이트를 검색할 수 있습니다.
 중요한 주의 사항은 웹 브라우저를 사용하여 캐싱을 테스트할 때 매우 주의해야 한다는 것입니다. 
 모든 최신 웹 브라우저에는 고유한 캐시가 있으므로 프록시의 캐시를 테스트하기 전에 이 캐시를 사용하지 않도록 설정해야 합니다.
 
핸드인 설명서
 
 제공되는 메이크 파일에는 최종 핸드인 파일을 구축할 수 있는 기능이 포함되어 있습니다. 작업 디렉토리에서 다음 명령을 실행합니다.
 
 linux>hand-in
 
 출력은 파일 ..../proxylab-handin.tar이며, 이 파일을 제출할 수 있습니다.
 
 사이트별: 여기에 각 학생에게 제출하는 방법을 알려주는 단락을 삽입합니다.
 proxylab-handin.tar 솔루션 파일입니다.
 
 • 교과서의 10-12장에는 시스템 수준의 I/O, 네트워크 프로그래밍, HTTP 프로토콜, 동시 프로그래밍에 대한 유용한 정보가 수록되어 있습니다.
 • RFC 1945(http://www.ietf.org/rfc/rfc1945.txt) 는 HTTP/1.0 프로토콜의 완전한 사양입니다.
 
 힌트
 • 교과서의 10.11절에서 논의한 바와 같이 소켓 입력 및 출력에 표준 I/O 기능을 사용하는 것은 문제가 됩니다. 
  대신 유인물 디렉토리의 csapp.c 파일에 제공되는 RIO(Robust I/O) 패키지를 사용하는 것이 좋습니다.
 • csapp.c에서 제공하는 오류 처리 기능은 서버가 연결을 수락하기 시작하면 종료하지 않도록 되어 있기 때문에 프록시에 적합하지 않습니다. 
  수정하거나 직접 작성해야 합니다.
 • 원하는 방식으로 유인물 디렉토리의 파일을 자유롭게 수정할 수 있습니다. 
   예를 들어, 모듈화를 잘하기 위해 캐시 기능을 cache.c 및 cache.h라는 파일에 라이브러리로 구현할 수 있습니다. 
   물론 새 파일을 추가하려면 제공된 Makefile을 업데이트해야 합니다.
 
 • CS의 964 페이지에 있는 사이드에서 설명한 바와 같이:
   APP3e 텍스트, 프록시는 SIGPIPE 신호를 무시해야 하며 EPIPE 오류를 반환하는 쓰기 작업을 적절하게 처리해야 합니다.
 • 간혹 너무 일찍 닫힌 소켓에서 바이트를 수신하기 위해 read를 호출하면 errno가 ECONRESET으로 설정된 상태에서 read가 -1로 반환됩니다. 
   이 오류로 인해 프록시가 종료되지 않아야 합니다.
 • 웹의 모든 콘텐츠가 ASCII 텍스트인 것은 아닙니다. 웹의 대부분의 콘텐츠는 이미지 및 비디오와 같은 이진 데이터입니다. 
   네트워크 I/O에 대한 함수를 선택하고 사용할 때 이진 데이터를 고려해야 합니다.
 • 원래 요청이 HTTP/1.1이더라도 모든 요청을 HTTP/1.0으로 전달합니다.
 
 행운을 빕니다.
